# Shader
Shader是GPU流水线上一些可以高度编程的阶段，这些代码在GPU中运行，并控制流水线中的渲染细节\

# 渲染流水线

## 由CPU主导的阶段

### 应用阶段
主要内容是设置场景数据，剔除不可见物体，设置渲染状态\
* 把数据加载到显存中
一般情况下GPU对内存没有访问权力，且GPU访问显存速度更快，因此CPU一般会将数据从硬盘中读取至内存，后将内存中的数据存于显存，方便显卡后续操作\
* 设置渲染状态
* 调用DrawCall
CPU发起让GPU开始渲染模型的指令\
实际是CPU发送渲染指令给OpenGL或DirectX，通过后者传递至显卡驱动，再由显卡驱动翻译命令使GPU工作\
CPU与GPU的配合实际是通过一个命令缓冲区实现的，类似于队列，CPU将命令放入队列，GPU则负责读取\
DrawCall增多影响帧率的原因是CPU将大量时间耗费在提交DrawCall命令上，类似多文件复制导致的速度减慢是一样的\
减少DrawCall的方法有减少较小的网格结构或将其合并，减少材质的使用\

## 由GPU主导的阶段
又称为GPU流水线\

### 几何阶段
主要内容是将顶点坐标变换为屏幕坐标，输出顶点的深度值、着色等信息\
* Vertex Shader | 顶点着色器
可编程，CPU传入GPU的每个顶点都会调用一次顶点着色器，主要完成坐标变换和逐顶点光照工作\
坐标变换是指将顶点坐标从模型空间转换到齐次裁剪坐标，再经过硬件处理得到归一化的设备坐标\
* Tessellation Shader | 曲面部分着色器
可选着色器，用于细分图元\
* Geometry Shader | 几何着色器
可选着色器，用于执行逐图元着色或产生更多的图元\
* 裁剪
一个图元和摄像机有3种关系，完全在视野内、部分在视野内、完全在视野外\
裁剪用于处理部分在摄像机视野内的物体，将位于视野外的图元图元进行处理，舍弃在视野外的顶点，贴边形成新的顶点\
* 屏幕映射
将齐次裁剪坐标(x,y,z)转换至屏幕坐标系(x1,y1)\
具体坐标值和设置的屏幕分辨率有关\
z并未被舍弃，而是和屏幕坐标一起合称窗口坐标系传递至光栅化阶段\
z表示深度值，对后续的深度测试有重要的影响作用\

### 光栅化阶段
主要内容是生成屏幕像素并渲染最终图像\
* 三角形设置
计算三角形网格表示数据的过程，主要包括计算三角网格对像素的覆盖情况等\
* 三角形遍历
根据顶点信息对在三角形设置中覆盖的像素进行插值，形成一个片元序列，这个序列包括了屏幕坐标、深度信息、法线、纹理坐标等信息\
* 片元着色器
对片元序列中每个像素进行颜色有关的信息输出，输出一个或多个颜色，最重要的是纹理采样，通过插值得到对应的纹理坐标\
* 逐片元操作
通过模板测试、深度测试等对每个片元进行可见性测试，通过测试的会与颜色缓冲区的颜色进行混合\
混合操作需要确定物体是否透明，对于透明物体需要对颜色缓冲区的颜色及当前片元颜色进行混合，而不透明物体则可以使用片元颜色直接更新颜色缓冲区，类似于ps中图层的合并\


# OpenGL与DirectX
实际是提供了显卡驱动与应用程序直接的接口过渡，CPU发送渲染指令给OpenGL或DirectX，通过后者传递至显卡驱动，再由显卡驱动翻译命令使GPU工作\


# HLSL与GLSL与Cg
HLSL是DirectX提供的着色语言，控制了着色器的编译，因此用不同硬件也有一致的编译效果，但仅限于微软相关平台的使用\
GLSL是OpenGL提供的着色语言，较HLSL相比有广泛的跨平台性，但其跨平台基于硬件供应商对GLSL的实现，因此不同硬件会产生不同的编译效果\
Cg是由Nvidia提供的着色语言，与微软合作，真正意义上的跨平台，基于不同的平台生成不同的中间语言，语法与HLSL很像，可以无缝移植为HLSL，但无法发挥OpenGL最新的特性\

## Unity Shader中的语言选择
可以使用Unity Cg或GLSL，Unity Cg与Cg略有不同，类似于Mono基于CLR的移植\

